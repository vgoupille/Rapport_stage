<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>discussion-copy</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="04-Discussion copy_files/libs/clipboard/clipboard.min.js"></script>
<script src="04-Discussion copy_files/libs/quarto-html/quarto.js"></script>
<script src="04-Discussion copy_files/libs/quarto-html/popper.min.js"></script>
<script src="04-Discussion copy_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="04-Discussion copy_files/libs/quarto-html/anchor.min.js"></script>
<link href="04-Discussion copy_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="04-Discussion copy_files/libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="04-Discussion copy_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="04-Discussion copy_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="04-Discussion copy_files/libs/bootstrap/bootstrap-973236bd072d72a04ee9cd82dcc9cb29.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="discussion" class="level1">
<h1>Discussion</h1>
<ul>
<li>rappel des obejectifs et questions de recherche</li>
<li>rappel des principaux resultats obtenus</li>
</ul>
<p>Discussion plan</p>
<ul>
<li><p>rappel objectif (Check method, Dol in bacteria)</p></li>
<li><p>Permis de voir courbes de croissance en conditions de stress ou pas (la prochaine fois utiliser des DO au même point) Ou faire une gamme préalable En stresss et non stress</p></li>
<li><p>Séquençage, déséquilibre influence légèrement qualité mais ok (juste être plus vigilant la proechaine fois)</p></li>
<li><p>trimming ok bien foncyonnne, reads de bonne qualité retirer adapteur (plus élabore que celui de kuchina)</p></li>
<li><p>STARsolo bien aussi car le plus plus rapide, amélioration possible avec pipeline de qui recup barcode si mauvaise qualité, BARQC serait bien tester si décalage</p></li>
<li><p>Mettre le nombre de reads qui passe chaque étape</p></li>
<li><p>Comme mentionné dans article bacSc et de nishimurz pas de pipeline existe</p></li>
<li><p>Filtrage est toujours subjectif chacun fais comme il veux en fonction de ce qu’il fait comme expérience microsplit. Dans les articles ne précise pas combien de cellules il vise dans chaque sous librairies dans à combien ils veulent Utiliser filtrage manuel des barcodes pour récupérer les meilleurs narcodes de chaque conditions (rep bio), Ici supposé que équilibre au départ</p></li>
</ul>
<p>On a vu un replica technique n’a pas marché (pipetage)</p>
<p>On a vu beaucoup moins de reads de qualités on a vu grise variabiliye entre les replica bio et les DO Déjà mentionné dans kuchina Influence du stade physio, peut être modification pariétal, lyse de cellules en conditions de stress (donc grande perte cellulaire) pas passé les filtre ou contraire certaine cellules pourrait se mettre en dormance/ renforcement paroi et donc exprimer très peu de gènes et donc pas facilement, comme proposé dans kuchina besoin de faire test. Si c’est le cas alors peut être que l’on a éliminé des cellules d’intérêt non stressé …</p>
<p>FACTEUR confondant pour le filtrage = &gt; difficulté associée pour le filtrage</p>
<p>Après conservation des gènes RNAm Dans la matrice gène on a très peut de gènes exprimés réellement (beaucoup de gènes avec 0 ou seulement 1 courts Même après normalitasyik et scale impossible de voir du signal, trop de variabilité lié à profondeur et replica technique, Voit umap lié profondeur de séquençage Chois focus od2 non stress De plus même si est ce que pas de clustering , et leindeb se fait avec profondeur</p>
<p>Cyriaque proposé de faire bulk et aussi faire blanc, permet d’améliorer méthodes stats</p>
<p>Ici premier test sur 3000 cellules pour voir si fonctionne et permet optimiser profondeur, peut de gène comparé à autres méthodes mais avantages population cellulaires élevé (40000) permet voir sous pop faible, aussi facilté de la méthode qui ne nécessita pas de matériel très coûteux spécifique</p>
<p>Pour chaque</p>
<p>Opter pour st - Comme mentionné dans</p>
<ul>
<li><p>marqueur gènes ;liste article</p></li>
<li><p>Amélioration possible : pipeline nfcore</p></li>
</ul>
<p>cela serait bien d’estimer la saturation de chauqe condition cela sera serait bien aussi de voir</p>
<p>This low variance structure could potentially be explained by the low RNA counts observed (@#fig-final_filtering <strong>?@fig-scaling</strong>). We hypothesize that the limited RNA capture efficiency of the single-cell method may not have captured sufficient RNA molecules, potentially resulting in high noise levels that can mask the real biological signal. mais peu aussi lier a mecanisme real dormance , mort cellulais</p>
<p><strong>Summary of preprocessing and filtering results:</strong> The preprocessing pipeline successfully removed sequencing artifacts and improved data quality, with an average 25.4% reduction in read counts across sublibraries. STARsolo analysis revealed excellent barcode quality (85.58% valid barcodes) and high sequencing quality (Q30 &gt; 95%), though the high sequencing saturation (0.97) requires careful interpretation due to potential technical artifacts. The filtering strategy effectively identified genuine cells while preserving biological variation, resulting in approximately 3,000 high-quality cells with clear differences between culture conditions. M9F medium consistently showed higher transcriptional activity compared to M9, with reduced expression under nutrient-limited conditions, particularly at later timepoints.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Recommendations for Future Experiments
</div>
</div>
<div class="callout-body-container callout-body">
<p>The observed size variations between sublibraries highlight the importance of balanced library preparation for optimal sequencing efficiency. Libraries of unequal sizes can lead to differential reagent consumption and varying quality across the flowcell. Future experiments should aim for more balanced library sizes to minimize technical artifacts and ensure consistent quality across all sublibraries.</p>
</div>
</div>
<p>We applied microSPLiT to P. brassicacearum growing in two different conditions in rich medium (M9F) and in minimal medium (M9).</p>
<p>-d’autres methodes de filtrage , log log comme dans…</p>
<p>While other tools exist for alignment and barcode reading in SPLiT-seq/microSPLiT protocols, such as Kallisto <span class="citation" data-cites="bray2016 sullivan2025">[@bray2016; @sullivan2025]</span>, The pipeline could be further improved with additional quality verification steps and implementation of workflow management systems such as Nextflow and nf-core for enhanced reproducibility and scalability.</p>
<pre><code>-   different other tools existe comme pour alignement et lecture des barcodes SPLiTseq/ microSPliT comme Kallisto [@bray2016], [@sullivan2025] mais d'apres le benchmarking de le plus rapide, reproductible est starsolo [@kuijpers2024]</code></pre>
<p>pleins parametre pour etre change, unique alignement peut de rRNA je trouve par rapport a autre articles</p>
<p>To remove empty and low gene detection barcodes, we applied the “knee” detection filter previously described in Brettner et al.&nbsp;202435. These quality-thresholded gene-by-barcode matrices were then converted to the R datatype, Seurat Objects, using the Seurat R package for further analyses83.</p>
<ul>
<li>biais de la methode</li>
<li>coloration fluorescences pour voir marqueur , cell states , i</li>
</ul>
<p>-agotation oiu pas</p>
<p>-discuter du pipeline bac -voir</p>
<ul>
<li><p>recepetion tardives des resultats</p></li>
<li><p>mis beaucoup de temps pour le trimming ( 1mois) le temps de comprendre la structure de la librairie et</p></li>
<li></li>
<li></li>
<li><p>analyse temporelle , metabolique , bulkRNAseq</p></li>
<li><p>utilisation pour capturer specifique mRNA (voir article : 2 methodes existes ; et apres aussi peut etre fait )</p></li>
<li><p>mais je pense deja bioinformatiquement on peut faire des choses pour ameliorer reads utilisables</p></li>
<li><p>comparer avec differentes methodes de single cell RNA seq, voir si on observe toujours la meme chose ou pas</p></li>
<li><p>versionnement des outils utilisés (renv , singularity, conda)</p></li>
<li><p>rapport fait un template pour rendu propre</p></li>
<li></li>
</ul>
<p>autres outils pourrait etre ajouter dans le pipeline comme BarQC alternative à Starsolo pour meilleur la lecture des barcodes (en considerant utilisant des positions non fixe (CIGAR motif) et evaluer la qualité UMIs et repartitions <span class="citation" data-cites="rossello">[@rossello]</span>,</p>
<p>pour la qualité et contamination : centriguge et recentrifuge <span class="citation" data-cites="martí2019 kim2016">[@martí2019; @kim2016]</span></p>
<p>meme si moins de risque de contamination car cellules fixé … (deve</p>
<ul>
<li>Nextflow pour le trimming, QC , et STARsolo serait une bonne idée , et barQC ; pourrait etre utile pour la communauté</li>
</ul>
<p>-autono -gestion des datas tailles des</p>
<p>, which typically corresponds to the mRNA proportion in the library</p>
<p>attention duplication des reads</p>
<p>serait bien de tester chaque sublirbai starsolo independant</p>
<section id="interpretation-of-key-findings" class="level2">
<h2 class="anchored" data-anchor-id="interpretation-of-key-findings">Interpretation of Key Findings</h2>
<section id="division-of-labor-mechanisms" class="level3">
<h3 class="anchored" data-anchor-id="division-of-labor-mechanisms">Division of Labor Mechanisms</h3>
</section>
<section id="biological-significance" class="level3">
<h3 class="anchored" data-anchor-id="biological-significance">Biological Significance</h3>
</section>
<section id="technical-considerations" class="level3">
<h3 class="anchored" data-anchor-id="technical-considerations">Technical Considerations</h3>
</section>
</section>
<section id="comparison-with-existing-literature" class="level2">
<h2 class="anchored" data-anchor-id="comparison-with-existing-literature">Comparison with Existing Literature</h2>
<section id="similarities-with-previous-studies" class="level3">
<h3 class="anchored" data-anchor-id="similarities-with-previous-studies">Similarities with Previous Studies</h3>
</section>
<section id="novel-insights" class="level3">
<h3 class="anchored" data-anchor-id="novel-insights">Novel Insights</h3>
</section>
<section id="discrepancies-and-their-implications" class="level3">
<h3 class="anchored" data-anchor-id="discrepancies-and-their-implications">Discrepancies and Their Implications</h3>
</section>
</section>
<section id="methodological-strengths-and-limitations" class="level2">
<h2 class="anchored" data-anchor-id="methodological-strengths-and-limitations">Methodological Strengths and Limitations</h2>
<section id="technical-advantages" class="level3">
<h3 class="anchored" data-anchor-id="technical-advantages">Technical Advantages</h3>
</section>
<section id="potential-limitations" class="level3">
<h3 class="anchored" data-anchor-id="potential-limitations">Potential Limitations</h3>
</section>
<section id="future-methodological-improvements" class="level3">
<h3 class="anchored" data-anchor-id="future-methodological-improvements">Future Methodological Improvements</h3>
</section>
</section>
<section id="biological-implications" class="level2">
<h2 class="anchored" data-anchor-id="biological-implications">Biological Implications</h2>
<section id="ecological-significance" class="level3">
<h3 class="anchored" data-anchor-id="ecological-significance">Ecological Significance</h3>
</section>
<section id="evolutionary-perspectives" class="level3">
<h3 class="anchored" data-anchor-id="evolutionary-perspectives">Evolutionary Perspectives</h3>
</section>
<section id="potential-applications" class="level3">
<h3 class="anchored" data-anchor-id="potential-applications">Potential Applications</h3>
</section>
</section>
<section id="future-research-directions" class="level2">
<h2 class="anchored" data-anchor-id="future-research-directions">Future Research Directions</h2>
<section id="open-questions" class="level3">
<h3 class="anchored" data-anchor-id="open-questions">Open Questions</h3>
</section>
<section id="suggested-follow-up-studies" class="level3">
<h3 class="anchored" data-anchor-id="suggested-follow-up-studies">Suggested Follow-up Studies</h3>
</section>
<section id="technical-improvements" class="level3">
<h3 class="anchored" data-anchor-id="technical-improvements">Technical Improvements</h3>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>