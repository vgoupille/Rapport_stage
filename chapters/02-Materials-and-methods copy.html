<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>materials-and-methods-copy</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="02-Materials-and-methods copy_files/libs/clipboard/clipboard.min.js"></script>
<script src="02-Materials-and-methods copy_files/libs/quarto-html/quarto.js"></script>
<script src="02-Materials-and-methods copy_files/libs/quarto-html/popper.min.js"></script>
<script src="02-Materials-and-methods copy_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="02-Materials-and-methods copy_files/libs/quarto-html/anchor.min.js"></script>
<link href="02-Materials-and-methods copy_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="02-Materials-and-methods copy_files/libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="02-Materials-and-methods copy_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="02-Materials-and-methods copy_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="02-Materials-and-methods copy_files/libs/bootstrap/bootstrap-973236bd072d72a04ee9cd82dcc9cb29.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="02-Materials-and-methods copy_files/libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="02-Materials-and-methods copy_files/libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="02-Materials-and-methods copy_files/libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="sec-materials-and-methods" class="level1">
<h1>Materials and Methods</h1>
<p>z</p>
<section id="bacterial-culture" class="level2">
<h2 class="anchored" data-anchor-id="bacterial-culture">Bacterial culture</h2>
<p>-boite petri population isogenique , puis culture en liquid medium</p>
<p><em>Pseudomonas brassicacearum</em> R401 was grown in liquid medium…. at …°C.</p>
<p>Two different conditions were applied to the bacteria :</p>
<ul>
<li><p>Low glucose and low iron (M9 medium)</p></li>
<li><p>High glucose and high iron (M9F medium)</p></li>
</ul>
<p>For each condition, 3 replicates were grown (biological replicates) and des cellules ont été prelevées de ces cultures. The DO was measured during the growth à 3 DO_timepoints (OD 0.1, 0.2, 0.3) Which do a total of 18 biological Samples/ Conditions (2 medium * 3 biological replicates * 3 timepoints)</p>
<p>Culture medium | Biological replicates | OD_timepoint</p>
<p>fig : plot curve of growth for each condition (ciblé et reel)</p>
<p>mes questions : est ce que replica bio, sont les meme entre stress et non stress ?voir avec Solène comment sont appliqué les stress (des debut ou apres un certain temps )=&gt; parler de ça en discussion =&gt; see annex for the media composition and more details</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Col1</th>
<th>Col2</th>
<th>Col3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Tableau des conditions biologiques : - figure / tableau et explications des conditions biologiques</p>
</section>
<section id="microsplit-protocol" class="level2">
<h2 class="anchored" data-anchor-id="microsplit-protocol">microSPLiT protocol</h2>
<section id="microsplit-barcoding" class="level3">
<h3 class="anchored" data-anchor-id="microsplit-barcoding">microSPLiT barcoding</h3>
<div id="fig-microsplit" class="lightbox quarto-float quarto-figure quarto-figure-center anchored" alt="MicroSPLiT Protocol">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-microsplit-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="../figures/protocol.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="Figure&nbsp;1: MicroSPLiT Protocol"><img src="../figures/protocol.png" title="Title: MicroSPLiT Protocol" class="img-fluid figure-img" alt="MicroSPLiT Protocol"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-microsplit-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: MicroSPLiT Protocol
</figcaption>
</figure>
</div>
<p>MicroSPLiT in-cell cDNA barcoding scheme. a, Bacterial cells are fixed overnight and permeabilized (Part 1, Steps 7–26) before the mRNA is preferentially polyadenylated (Part 1, Step 34). After mRNA enrichment, cells may contain both polyadenylated and non-polyadenylated mRNA. b, Cells are distributed into the first barcoding plate, and the mRNA is reverse transcribed by using a mixture of poly-dT and random hexamer primers carrying a barcode (barcode 1, BC1) and a 5’ phosphate for future ligation at their 5’ end (Part 1, Step 41). After the barcoding reaction, cells are pooled together and split again into the second barcoded plate (Part 1, Steps 43–52). c, Ligation adds a 5’ phosphorylated barcode 2 (BC2) to BC1 with a linker strand. A blocking solution is then added to each of the wells of the second plate, preventing any unreacted BC2 from future ligation (Part 1, Step 56). Cells are pooled and split into the third and final barcoded plate (Part 1, Steps 58–61). d, A second ligation step adds barcode 3 (BC3) with another linker strand. BC3 also contains a 5’ biotin, a primer binding site and a unique molecular identifier (UMI). A blocking solution for the R3 linker is added to each of the wells in the plate before the final pooling of cells (Part 1, Step 64). This results in uniquely barcoded cells that can be distributed in aliquots into sub-libraries and stored until future use or used immediately for library preparation. R1, round 1; R2, round 2; R3, round 3.</p>
<ul>
<li>Microbial split-pool ligation transcriptomics (microSPLiT) protocol was performed as described in <span class="citation" data-cites="gaisser2024">[@gaisser2024]</span> and <span class="citation" data-cites="kuchina2021">[@kuchina2021]</span>. It’s a high-throughput single-cell RNA sequencing method for bacteria can profile transcriptional states in hundreds of thousands of bacteria in a single experiment without specialized equipment.</li>
</ul>
<p>As bacterial samples are fixed and permeabilized before barcoding, they can be collected and stored ahead of time.</p>
<p>Contrary to other single-cell RNA sequencing methods, microSPLiT does not require the isolation of individual cells.</p>
<p>Instead of lysing bacteria and releasing the transcripts from each cell into a barcoding reaction vessel, in microSPLiT, each cell is the vessel enclosing its own transcripts. microSPLiT preserves the intact bacterial cell as a reaction compartment, enabling in situ barcoding of intracellular RNA.</p>
<section id="fixation-and-permeabilization" class="level4">
<h4 class="anchored" data-anchor-id="fixation-and-permeabilization">Fixation and permeabilization</h4>
<section id="fixation" class="level5">
<h5 class="anchored" data-anchor-id="fixation">Fixation</h5>
<p>For each sample, Bacterial cells are collected in bulk and fixed using formaldehyde. Fixation has two essential roles: - It preserves the transcriptomic state of each cell at the time of sampling. - It creates covalent cross-links between RNA and intracellular proteins, thereby preventing RNA leakage during later processing. - Importantly, fixation must retain the physical integrity of the cells to ensure downstream single-cell analysis is possible.</p>
</section>
<section id="permeabilization" class="level5">
<h5 class="anchored" data-anchor-id="permeabilization">Permeabilization</h5>
<p>Permeabilization is the process of making the cell membrane permeable to allow the entry of molecules. In microSPLiT, the cell wall/cell membrane is permeabilized using a combination of detergents and enzymes. The aim is to permeabilize the cell envelope without disrupting cell structure. This allows external enzymes (e.g., poly(A) polymerase, reverse transcriptase, ligase) and oligonucleotides to enter the cell. A key balance must be achieved: sufficient permeabilization for enzyme access, but minimal structural damage to maintain single-cell resolution.</p>
</section>
</section>
<section id="in-cell-polyadenylation" class="level4">
<h4 class="anchored" data-anchor-id="in-cell-polyadenylation">In-cell polyadenylation</h4>
<p>After permeabilization, the transcripts in the fixed and permeabilized cells undergo in situ polyadenylation with the addition of Escherichia coli poly(A) polymerase (PAP) and ATP. This step enriches for mRNA in the total barcoded RNA pool because, under these conditions, PAP preferentially polyadenylates mRNA as opposed to rRNA.</p>
<p>During the first barcoding round, the fixed and permeabilized bacteria are distributed into a 96-well plate, where their transcripts are reverse transcribed into cDNA and labeled with the first well-specific barcode inside the cells. The cells are mixed and redistributed two more times into new 96-well plates, where the second and third barcodes are appended to the cDNA via in-cell ligation reactions. Finally, the cells are mixed and divided into aliquot sub-libraries, which can be stored until future use or prepared for sequencing with the addition of a fourth barcode. It takes 4 days to generate sequencing-ready libraries, including 1 day for collection and overnight fixation of samples.</p>
<p>microSPLiT barcoding</p>
<p>Instead of lysing bacteria and releasing the transcripts from each cell into a barcoding reaction vessel, in microSPLiT, each cell is the vessel enclosing its own transcripts. The procedure starts with the collection of cells in bulk and the fixation of the bacterial suspension with formaldehyde. It then proceeds with permeabilization by using sequential mild detergent and lysozyme treatments (Fig. 1a). Fixation is critical because it both preserves the cellular transcriptomic state and covalently cross-links the transcripts with the proteins inside the cells to prevent leakage after permeabilization.</p>
<p>The permeabilization step ensures that the externally supplied enzymes and oligonucleotides can access the RNA transcripts in the fixed intracellular milieu. While sufficient permeabilization is crucial to the efficiency of barcoding, it is also critical to preserve the physical integrity of the fixed cells to maintain the single-cell resolution of the method.</p>
<p>We emphasize that for a successful microSPLiT experiment, the cells, after permeabilization, must still exist as intact, individual units to permit several split and pool steps and hold together the cross-linked RNA. After permeabilization, the transcripts in the fixed and permeabilized cells undergo in situ polyadenylation with the addition of Escherichia coli poly(A) polymerase (PAP) and ATP. This step enriches for mRNA in the total barcoded RNA pool because, under these conditions, PAP preferentially polyadenylates mRNA as opposed to rRNA.</p>
</section>
<section id="round-barcoding" class="level4">
<h4 class="anchored" data-anchor-id="round-barcoding">round barcoding</h4>
<p>on split les 18 samples , en 5 pour avoir des replicats techni donc on obtient 90 samples , permettra d’evaluer la variance technique</p>
<p>depot meme quantité de cellules dans chaque puit</p>
<section id="round-1-barcoding" class="level5">
<h5 class="anchored" data-anchor-id="round-1-barcoding">round 1 barcoding</h5>
<p>les 90 samples sont reparties dans 90 puits distincts, chacun contenant un unique primer barcodé</p>
<p>In the next step, the cell suspension and each sample is distributed into a 96-well plate with uniquely barcoded primers in each well (Fig. 1b, round 1 (R1) reverse transcription (RT) working plate).</p>
<p>The mRNA is then converted to cDNA through in-cell RT with a mixture of barcoded poly(T) and random hexamer primers. cette etape de barcoding permet demarquer les cellules par condition</p>
</section>
<section id="round-2-barcoding" class="level5">
<h5 class="anchored" data-anchor-id="round-2-barcoding">round 2 barcoding</h5>
<p>Cells are then pooled, washed and randomly redistributed into a new 96-well plate (round 2 (R2) ligation working plate) containing a second set of well-specific barcodes, which are appended to the first barcode on the cDNA through an in-cell ligation reaction (Fig. 1c). Because of the random cell distribution, there is a high chance that each well of the secondround plate will contain cells with a mixture of different first-round barcodes, creating diverse barcode combinations.</p>
</section>
<section id="round-3-barcoding" class="level5">
<h5 class="anchored" data-anchor-id="round-3-barcoding">round 3 barcoding</h5>
<p>Cells are then pooled again, and a split-ligation-pool cycle is repeated for the second time. Cells are randomly distributed into a third 96-well plate (round 3 (R3) ligation working plate), which is loaded with barcoded oligonucleotides containing the third cell barcode annealed with a linker, a 10-base unique molecular identifier (UMI), a common PCR handle and a 5’ biotin molecule . en réalité ici 95 a la place de 96 pref separer</p>
<p>90<em>96</em>95 = 820800 combinations de barcodes possibles =&gt; autant de cellules individuelles possibles</p>
</section>
</section>
<section id="section" class="level4">
<h4 class="anchored" data-anchor-id="section"></h4>
<p>The pooled cells are washed, counted and divided into sub-libraries of variable sizes, which can be stored at -80 °C for &gt;=6 months before proceeding with sequencing library preparation. Dividing sub-libraries into aliquots has two main advantages. First, it allows fine control over the number of cells in the final sequencing libraries. The size of a sub-library can be chosen so that the number of cells that receive the same barcode combination by chance does not exceed the desired collision rate (Table 1). It also permits multiplexing several libraries, potentially even from different experiments, in a single sequencing run.</p>
<p>on choisi de sequencer la plus petite librairie, celle avec 3000 cellules afin d’avoir de maximiser la profondeur de sequençage et limiter le nombre de collision rate (0.34 quand 96<em>96</em>96) et avoir un nombre suffisant de cellules pour avoir un signal</p>
<p>90 samples see annex for the plate with barcoded primers</p>
</section>
</section>
<section id="microsplit-sequencing-library-preparation" class="level3">
<h3 class="anchored" data-anchor-id="microsplit-sequencing-library-preparation">microSPLiT sequencing library preparation</h3>
</section>
</section>
<section id="other-remarks" class="level2">
<h2 class="anchored" data-anchor-id="other-remarks">other remarks</h2>
<p>Bacterial culture (Biological conditions) Before to explain the microSPLiT the experimental methods are presented.</p>
<p>see the protocol of - deux conditions env : stress (low_glucose_low fer) / pas stress</p>
<ul>
<li><p>suivi temporel à 3 timepoints (peut etre discuter de ce point après car les mesures de do ont été fait a des temps précis et variation de DO entre les reelles et attendus )</p></li>
<li><p>3 replicats biologiques par condition</p></li>
<li><p>5 replicats techniques par replicat biologique</p></li>
</ul>
<p>=&gt; un nombre cellules visés de 3000 cellules au totale (voir annexes pour le choix cela )</p>
<p>=&gt; voir annexe pour le plan de plaques</p>
<p>=&gt; donc 90 echantillons differents</p>
<p>=&gt; rep bio : voir si variation entre les populations =&gt; replica techn : permettre d’estimer si variance dans le nombre - utilisation du nombre d’UMIs dans le round1 pour estimer cela =&gt; voir resultats : pooler ensemble</p>
<p>dans l’hypothèse equilibre parfaite a noté que 33 cellules par conditions ce qui est tres faible =&gt; peut etre soumis à des variations individuels au qui pourrait rendre difficule evalutaion variation (tirage aléatoire, possible cellules avec faible activi ou inverse (desequilibre))</p>
<p>=&gt; discussion : renvoie vers l’outils Shiny pour voir les conditions biologiques permet une visualisation plus rapide des donnees</p>
</section>
<section id="microsplit" class="level2">
<h2 class="anchored" data-anchor-id="microsplit">MicroSPLiT</h2>
<p>figure du protocole microsplit</p>
<ul>
<li><p>explication de la méthode microSPLiT <span class="citation" data-cites="brettner2024 kuchina2021">[@brettner2024; @kuchina2021]</span></p></li>
<li><p>pour faire simple : differentes etape : fixation ; …;</p></li>
<li><p>contrairement aux autres methodes, pas d’isolation individuelle des cellules</p></li>
<li><p>3 rounds de split-pool : le premier round on affecte les differentes conditions biologiques</p></li>
<li><p>un 4eme round pour rajouté un UMI pour les differentes libraires de sequençage</p></li>
</ul>
<p>-envoie d’un pool de librairies à la plateforme de sequençage - sequençage de type NovaSeq™ X Plus par la plateforme GenoBIRD , et demulteplexé permet d’amelioré la qualité de sequençage</p>
<ul>
<li><p>renvoie vers le protocole de kuchina 2021 et bretner 2024 <span class="citation" data-cites="brettner2024 kuchina2021">[@brettner2024; @kuchina2021]</span> pour l’explication de la méthode en detail</p></li>
<li><p>=&gt; discussion des limites de cette methode dans la partie discussion</p></li>
<li><p>ce qui est importantes de comprendre c’est que cela repose sur un methodes mathematiques combinatoires mais pas methodes d’isolation en tant que tel .</p></li>
<li><p>un grand nombre de cellules ont été barcodés : plusieurs dizaines ou 100aines de milliers mais seulemtnn pres de 3000 cellules ont été choisi pour le sequencçage :<br>
voir annex pour le tableau de choix du nombre de cellules pour la librairies (est un compromis pour avoir suffissament de cellules potentielles mais pas trop pour ne pas avoir des librairies trop grandes qui pourrait entrainer un profondeur de sequençage pas suffisante ) =&gt; discussion sur le nombre de cellules choisi pour la librairie</p></li>
</ul>
</section>
<section id="librairies-structures" class="level2">
<h2 class="anchored" data-anchor-id="librairies-structures">Librairies structures</h2>
<p>-stucture de la librairie</p>
<ul>
<li><p>figure : Final librairies structure</p></li>
<li><p>R1 contient la sequence d’interet</p></li>
<li><p>R2 contient les barcodes</p></li>
<li><p>polyA ou random_hexamer</p></li>
</ul>
<p>-&gt; key point : dans chauque puit polyA et random</p>
<p>=&gt; voir annex pour la structure complete avec TSO… =&gt; discussion sur TSO</p>
<p>-STARsolo permet l’alignements des reads et lectures des barcodes - details de methode d’alignements partielles ou non … - tailles des reads que j’ai alignés</p>
</section>
</section>
<section id="pipeline-of-the-analysis" class="level1">
<h1>Pipeline of the analysis</h1>
<ul>
<li>figure of the pipeline</li>
</ul>
<p>Preprocesing sur le cluster genouest, la suite en local et sur le cluster aussi (peut etre) tous les scripts sont dispo sur differents depots githubs</p>
<ul>
<li><p>differentes etapes :</p>
<ul>
<li><p>demultiplexage des index de librairies (réalisé par la plateforme de sequençage)</p></li>
<li><p>QC control des données avec Andrews, S. (2010). FastQC: &nbsp;A&nbsp;Quality Control Tool for High Throughput Sequence Data [Online]. Available online at:&nbsp;<a href="http://www.bioinformatics.babraham.ac.uk/projects/fastqc/" class="uri">http://www.bioinformatics.babraham.ac.uk/projects/fastqc/</a> et avec <span class="citation" data-cites="ewels2016">[@ewels2016]</span></p></li>
<li><p>trimming des données de seqeunçage avec Fastp <span class="citation" data-cites="chen2018">[@chen2018]</span> et Cutadapt <span class="citation" data-cites="martin2011">[@martin2011]</span></p></li>
<li><p>aligment des data sur le genome de reference de <em>Pseudomonas brassicacearum</em> grace à STARsolo un amelioration de l’outils STAR pour les données single-cell [<span class="citation" data-cites="dobin2013">@dobin2013</span>]<span class="citation" data-cites="kaminow">[@kaminow]</span></p></li>
<li><p>different other tools existe comme pour alignement et lecture des barcodes SPLiTseq/ microSPliT comme Kallisto <span class="citation" data-cites="bray2016">[@bray2016]</span>, <span class="citation" data-cites="sullivan2025">[@sullivan2025]</span> mais d’apres le benchmarking de le plus rapide, reproductible est starsolo <span class="citation" data-cites="kuijpers2024">[@kuijpers2024]</span></p>
<p>Although single‐cell sequencing approaches have been developed for several molecular modalities, single‐cell transcriptome sequencing is the most prevalent and widely applied technique. SPLiT‐seq (split‐pool ligation‐based transcriptome sequencing) is one of these single‐cell transcriptome techniques that applies a unique combinatorial‐barcoding approach by splitting and pooling cells into multi‐well plates containing barcodes. This unique approach required the development of dedicated computational tools to preprocess the data and extract the count matrices. Here we compare eight bioinformatic pipelines (alevin‐fry splitp, LR‐splitpipe, SCSit, splitpipe, splitpipeline, SPLiTseq‐demultiplex, STARsolo and zUMI) that have been developed to process SPLiT‐seq data.</p></li>
<li><p>Metadata assignation to seura</p></li>
</ul></li>
</ul>
<p>=&gt; d’autres étapes ou autres outils pourrait etre ajouter dans le pipeline (voir la partie disccussion)</p>
<ul>
<li>differnetes steps of the pipeline</li>
<li></li>
<li>assignation des metadonnées (utilisation d’un genome de reference =&gt; discussion )</li>
</ul>
<section id="demultiplexing" class="level3">
<h3 class="anchored" data-anchor-id="demultiplexing">Demultiplexing</h3>
</section>
<section id="section-1" class="level3">
<h3 class="anchored" data-anchor-id="section-1"></h3>
</section>
<section id="section-2" class="level3">
<h3 class="anchored" data-anchor-id="section-2"></h3>
</section>
<section id="starsolo" class="level3">
<h3 class="anchored" data-anchor-id="starsolo">STARsolo</h3>
<p>500 go</p>
<p>attention je vais devoir dire les version des outils utilisés</p>
<p>github,</p>
<p>differentes etapes mais pas detailler tous ici renvoie vers le codes commenter et les readme pour comprendre en details telechangement des fichiers, decompression .zip ; 4 fichier , analyse indenpendant de la qualité des 4 librair, trimming</p>
<p>parallelisation pour ganger du temps …</p>
<section id="final-effective-command-line-of-starsolo" class="level5">
<h5 class="anchored" data-anchor-id="final-effective-command-line-of-starsolo">Final effective command line of STARsolo:</h5>
<p><strong>STAR</strong><br>
<strong>–runThreadN</strong> 64<br>
<strong>–genomeDir</strong> /path/to/genome_index<br>
<strong>–readFilesIn</strong><br>
/path/to/input/merged_trimmed-R1.fastq.gz<br>
/path/to/input/merged_trimmed-R2.fastq.gz<br>
<strong>–readFilesCommand</strong> gunzip -c<br>
<strong>–outFileNamePrefix</strong> /path/to/output/starsolo_output/<br>
<strong>–outSAMtype</strong> BAM Unsorted<br>
<strong>–outFilterScoreMinOverLread</strong> 0<br>
<strong>–outFilterMatchNmin</strong> 50<br>
<strong>–outFilterMatchNminOverLread</strong> 0<br>
<strong>–alignSJoverhangMin</strong> 1000<br>
<strong>–alignSJDBoverhangMin</strong> 1000<br>
<strong>–soloType</strong> CB_UMI_Complex<br>
<strong>–soloCBwhitelist</strong><br>
/path/to/barcodes/barcode_round3.txt<br>
/path/to/barcodes/barcode_round2.txt<br>
/path/to/barcodes/barcode_round1.txt<br>
<strong>–soloFeatures</strong> Gene GeneFull<br>
<strong>–soloUMIdedup</strong> 1MM_All<br>
<strong>–soloCBmatchWLtype</strong> 1MM<br>
<strong>–soloCBposition</strong> 0_10_0_17 0_48_0_55 0_78_0_85<br>
<strong>–soloUMIposition</strong> 0_0_0_9<br>
<strong>–soloMultiMappers</strong> Uniform</p>
</section>
</section>
<section id="starsolo-parameters-explanation" class="level3">
<h3 class="anchored" data-anchor-id="starsolo-parameters-explanation">STARsolo Parameters Explanation</h3>
<p>This section details the key parameters used in our STARsolo analysis and their significance:</p>
<section id="general-star-parameters" class="level4">
<h4 class="anchored" data-anchor-id="general-star-parameters">General STAR Parameters</h4>
<ul>
<li><code>--runThreadN 64</code> : Use of 64 threads for parallel alignment</li>
<li><code>--genomeDir</code> : Path to the reference genome index</li>
<li><code>--readFilesIn</code> : Input FASTQ files (R1 and R2)</li>
<li><code>--readFilesCommand gunzip -c</code> : Command to decompress FASTQ.gz files</li>
<li><code>--outFileNamePrefix</code> : Prefix for output files</li>
<li><code>--outSAMtype BAM Unsorted</code> : Unsorted BAM output format</li>
</ul>
</section>
<section id="filtering-parameters" class="level4">
<h4 class="anchored" data-anchor-id="filtering-parameters">Filtering Parameters</h4>
<ul>
<li><code>--outFilterScoreMinOverLread 0</code> : Minimum filtering score relative to read length</li>
<li><code>--outFilterMatchNmin 50</code> : Minimum number of matching bases for a valid alignment</li>
<li><code>--outFilterMatchNminOverLread 0</code> : Minimum match ratio relative to read length</li>
<li><code>--alignSJoverhangMin 1000</code> and <code>--alignSJDBoverhangMin 1000</code> : Strict parameters for splice junction detection</li>
</ul>
</section>
<section id="starsolo-specific-parameters" class="level4">
<h4 class="anchored" data-anchor-id="starsolo-specific-parameters">STARsolo-specific Parameters</h4>
<ul>
<li><code>--soloType CB_UMI_Complex</code> : Analysis type for cell barcodes (CB) and complex UMIs</li>
<li><code>--soloCBwhitelist</code> : List of valid cell barcodes for the three barcoding rounds</li>
<li><code>--soloFeatures Gene GeneFull</code> : Analysis of features at both gene and full transcript levels</li>
<li><code>--soloUMIdedup 1MM_All</code> : UMI deduplication with one mutation tolerance</li>
<li><code>--soloCBmatchWLtype 1MM</code> : Cell barcode matching with one mutation tolerance</li>
<li><code>--soloCBposition</code> : Cell barcode positions in reads (3 rounds)
<ul>
<li>Round 1: 0_10_0_17</li>
<li>Round 2: 0_48_0_55</li>
<li>Round 3: 0_78_0_85</li>
</ul></li>
<li><code>--soloUMIposition 0_0_0_9</code> : UMI position in reads</li>
<li><code>--soloMultiMappers Uniform</code> : Uniform distribution of multi-mapped reads</li>
</ul>
<p>These parameters were chosen to optimize single-cell detection while maintaining high alignment quality and accounting for the complexity of our three-round barcoding protocol.</p>
<p>Parfait ! Maintenant je peux interpréter vos données de croissance avec les valeurs réelles. Voici l’analyse détaillée :</p>
</section>
</section>
<section id="interprétation-des-courbes-de-croissance---données-réelles" class="level2">
<h2 class="anchored" data-anchor-id="interprétation-des-courbes-de-croissance---données-réelles"><strong>Interprétation des courbes de croissance - Données réelles</strong></h2>
<section id="comparaison-entre-conditions-m9-et-m9f" class="level3">
<h3 class="anchored" data-anchor-id="comparaison-entre-conditions-m9-et-m9f"><strong>Comparaison entre conditions M9 et M9F :</strong></h3>
<section id="croissance-au-point-t1-od-cible-0.1" class="level4">
<h4 class="anchored" data-anchor-id="croissance-au-point-t1-od-cible-0.1"><strong>1. Croissance au point T1 (OD cible 0.1) :</strong></h4>
<ul>
<li><strong>M9</strong> : OD mesurée = 0.130 (légèrement supérieure à la cible)</li>
<li><strong>M9F</strong> : OD mesurée = 0.173-0.208 (supérieure à la cible et à M9)</li>
<li><strong>Interprétation</strong> : Les bactéries en M9F ont déjà une croissance plus importante au premier point de mesure</li>
</ul>
</section>
<section id="croissance-au-point-t2-od-cible-0.2" class="level4">
<h4 class="anchored" data-anchor-id="croissance-au-point-t2-od-cible-0.2"><strong>2. Croissance au point T2 (OD cible 0.2) :</strong></h4>
<ul>
<li><strong>M9</strong> : OD mesurée = 0.280-0.328 (supérieure à la cible)</li>
<li><strong>M9F</strong> : OD mesurée = 0.588-0.627 (très supérieure à la cible et à M9)</li>
<li><strong>Interprétation</strong> : L’écart entre les deux conditions s’accentue fortement</li>
</ul>
</section>
<section id="croissance-au-point-t3-od-cible-0.3" class="level4">
<h4 class="anchored" data-anchor-id="croissance-au-point-t3-od-cible-0.3"><strong>3. Croissance au point T3 (OD cible 0.3) :</strong></h4>
<ul>
<li><strong>M9</strong> : OD mesurée = 0.260 (légèrement inférieure à la cible)</li>
<li><strong>M9F</strong> : OD mesurée = 0.740-0.834 (très supérieure à la cible et à M9)</li>
<li><strong>Interprétation</strong> : Les cultures M9 semblent avoir atteint un plateau, tandis que M9F continue de croître</li>
</ul>
</section>
</section>
<section id="analyse-de-la-variabilité" class="level3">
<h3 class="anchored" data-anchor-id="analyse-de-la-variabilité"><strong>Analyse de la variabilité :</strong></h3>
<section id="réplicats-m9" class="level4">
<h4 class="anchored" data-anchor-id="réplicats-m9"><strong>Réplicats M9 :</strong></h4>
<ul>
<li><strong>Rep A et B</strong> : Identiques (0.130, 0.280, 0.260)</li>
<li><strong>Rep C</strong> : Légèrement différent au T2 (0.328 vs 0.280)</li>
<li><strong>Interprétation</strong> : Excellente reproductibilité, sauf un léger écart pour le réplicat C</li>
</ul>
</section>
<section id="réplicats-m9f" class="level4">
<h4 class="anchored" data-anchor-id="réplicats-m9f"><strong>Réplicats M9F :</strong></h4>
<ul>
<li><strong>Variabilité modérée</strong> : OD variant de 0.168-0.208 (T1), 0.588-0.627 (T2), 0.740-0.834 (T3)</li>
<li><strong>Interprétation</strong> : Bonne reproductibilité avec une variabilité naturelle attendue</li>
</ul>
</section>
</section>
<section id="conclusions-biologiques" class="level3">
<h3 class="anchored" data-anchor-id="conclusions-biologiques"><strong>Conclusions biologiques :</strong></h3>
<ol type="1">
<li><p><strong>Effet du milieu nutritif</strong> : Le milieu M9F (riche en glucose et fer) permet une croissance nettement supérieure à M9 (pauvre)</p></li>
<li><p><strong>Phase de croissance</strong> :</p>
<ul>
<li>M9 semble atteindre un plateau vers T3 (OD ~0.26)</li>
<li>M9F continue sa croissance exponentielle jusqu’à T3 (OD ~0.8)</li>
</ul></li>
<li><p><strong>Limitation nutritive</strong> : Les bactéries en M9 sont probablement limitées par la disponibilité en glucose et/ou fer</p></li>
<li><p><strong>Robustesse expérimentale</strong> : Les réplicats montrent une bonne reproductibilité, validant la qualité de l’expérience</p></li>
</ol>
</section>
<section id="implications-pour-lanalyse-single-cell" class="level3">
<h3 class="anchored" data-anchor-id="implications-pour-lanalyse-single-cell"><strong>Implications pour l’analyse single-cell :</strong></h3>
<p>Ces différences de croissance suggèrent que les cellules en M9 et M9F seront dans des états physiologiques très différents, ce qui devrait se refléter dans leurs profils d’expression génique lors de l’analyse RNA-seq.</p>
<div id="fig-protocol" class="lightbox quarto-float quarto-figure quarto-figure-center anchored" alt="microSPLiT protocol.">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-protocol-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="../figures/protocol.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2" title="Figure&nbsp;2: microsplit_protocol"><img src="../figures/protocol.png" title="Title: microSPLiT protocol" class="img-fluid figure-img" alt="microSPLiT protocol."></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-protocol-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: microsplit_protocol
</figcaption>
</figure>
</div>
<p>The microSPLiT protocol was used to isolate the mRNA from the bacteria. The protocol is described in <a href="#fig-protocol" class="quarto-xref">Figure&nbsp;2</a>.</p>
<p>The protocol was adapted to the bacteria used in this study. The bacteria were grown in the M9 and M9F media. The bacteria were collected at each timepoint (T1, T2, T3) from all biological replicates. The bacteria were then lysed and the mRNA was isolated using the microSPLiT protocol. The mRNA was then sequenced using the Illumina platform.</p>
<p>The microSPLiT protocol is a single-cell RNA-seq protocol that allows the isolation of the mRNA from the bacteria. The protocol is described in <a href="#fig-protocol" class="quarto-xref">Figure&nbsp;2</a>.</p>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>